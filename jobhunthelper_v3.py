# -*- coding: utf-8 -*-
"""JobHuntHelper.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fRXwhZPQ85BIyXtEQJKq5KGeK7UnnLet
"""

!pip install telebot > null
!pip install selenium > null
!apt-get update > null
!apt-get install -y chromium-chromedriver > null
!pip install mysql-connector-python > null
!pip install schedule > null
!pip install config > null

import telebot
import mysql.connector
import requests
import codecs
import re
import time
import schedule
import threading
import config

from telebot import types
from enum import Enum
from urllib.parse import urlencode
from selenium import webdriver
from threading import Lock
from urllib.parse import urlencode, quote
from bs4 import BeautifulSoup as BS
from random import randint
from urllib.parse import urlencode

from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from itertools import chain

from telebot.apihelper import ApiTelegramException
from telebot.types import ReplyKeyboardMarkup, KeyboardButton
from datetime import datetime
from dateutil.relativedelta import relativedelta

class DatabaseManager:
    def __init__(self, config):
        self.config = config
        self.connection_pool = mysql.connector.pooling.MySQLConnectionPool(
            pool_name="my_pool",
            pool_size=5,
            **config
        )
        self.query_lock = Lock()

    def get_connection(self):
        return self.connection_pool.get_connection()

    def execute_query(self, query, params=None):
       with self.query_lock:
          connection = self.get_connection()
          cursor = connection.cursor()
          try:
              if params:
                  cursor.execute(query, params)
              else:
                  cursor.execute(query)

              # Если запрос предполагает возвращение данных (SELECT), получаем результаты
              if query.strip().upper().startswith('SELECT'):
                  results = cursor.fetchall()
              else:
                  # Для запросов, модифицирующих данные (INSERT, UPDATE, DELETE), сохраняем изменения и возвращаем None
                  connection.commit()
                  results = []

          except Exception as e:
              print(f"Ошибка при выполнении запроса: {e}")
              results = None

          cursor.close()
          connection.close()
          return results

    def get_requests_from_db(self):
        query = """
            SELECT * FROM requests
            """
        return db_manager.execute_query(query)
#db_manager = DatabaseManager(config)
#result = db_manager.execute_query("SELECT * FROM requests")
#print(result)

class EXPERIENCE(Enum):
  DEFAULT_VALUE = -2
  STUDENT = -1
  WITHOUT_EXPERIENCE = 0
  ONE_YEAR = 1
  TWO_YEAR = 2
  THREE_YEAR = 3
  FOUR_YEAR = 4
  FIVE_YEAR = 5

def build_url(base_url, **params):
  # Видаляємо всі елементи, які мають None або порожнє значення
  filtered_params = {k: v for k, v in params.items() if v}
  query_string = urlencode(filtered_params)
  return f"{base_url}?{query_string}" if query_string else base_url

def build_url_djinni(**params):
  base_url = "https://djinni.co/jobs/"

  params["location"] = params["location"].lower()
  if params["location"] == "remote":
    params["employment"]="remote"
    del params["location"]

  if params["exp_level"] == EXPERIENCE.DEFAULT_VALUE.value or params["exp_level"] > EXPERIENCE.FIVE_YEAR.value:
     params["exp_level"] = ""
  else:
     params["exp_level"] = str(params["exp_level"]) + 'y'
  if params["exp_level"] == "0y":
     params["exp_level"] = "no_exp"

  params["exp_rank"] = params["exp_rank"].lower()
  return build_url(base_url, **params)

def build_url_workua(language='', city='', position='', min_salary=0, experience=EXPERIENCE.DEFAULT_VALUE.value, **params):
  base_url = "https://www.work.ua/jobs"
  if city:
    base_url += '-' + city
  if language:
    base_url += '-' + quote(language)
  if position:
    base_url += '+' + position
  base_url += '/'
  salaryidfrom=''
  if min_salary:
    if 3000 <= min_salary and min_salary < 5000:
      params["salaryfrom"] = 2
    elif 5000 <= min_salary and min_salary < 7000:
      params["salaryfrom"] = 3
    elif 7000 <= min_salary and min_salary < 10000:
      params["salaryfrom"] = 4
    elif 10000 <= min_salary and min_salary < 15000:
      params["salaryfrom"] = 5
    elif 15000 <= min_salary and min_salary < 20000:
      params["salaryfrom"] = 6
    elif 20000 <= min_salary and min_salary < 30000:
      params["salaryfrom"] = 7
    elif min_salary > 30000:
      params["salaryfrom"] = 8

  if experience == EXPERIENCE.WITHOUT_EXPERIENCE.value:
    params["experience"] = 1
  elif experience == EXPERIENCE.STUDENT.value:
    params["student"] = 1

  return build_url(base_url, **params)


def convert_uah_to_usd_for_djinni(uah_amount, exchange_rate):
  # Визначаємо список значень для округлення
  round_values = [1500, 2500, 3500, 4500, 5500, 6500, 7500, 8500]
  usd_amount = uah_amount / exchange_rate
  if (usd_amount < 1500):
    return ''
  rounded_down_value = max([value for value in round_values if value <= usd_amount], default=min(round_values))
  return rounded_down_value

def build_url_dou(**params):
  base_url = "https://jobs.dou.ua/vacancies/"
  if params["city"] == "remote":
      del params["city"]
      params["remote"] = 'remote'

  if params.get("position"):
      params["search"] += " " + params["position"]
      del params["position"]
  if params["exp"] == EXPERIENCE.STUDENT.value or params["exp"] == EXPERIENCE.WITHOUT_EXPERIENCE.value or params["exp"] == EXPERIENCE.ONE_YEAR.value:
     params["exp"] = "0-1"
  elif params["exp"] == EXPERIENCE.TWO_YEAR.value or params["exp"] == EXPERIENCE.THREE_YEAR.value:
     params["exp"] = "1-3"
  elif params["exp"] == EXPERIENCE.FOUR_YEAR.value or params["exp"] == EXPERIENCE.FIVE_YEAR.value:
     params["exp"] = "3-5"
  elif params["exp"] > EXPERIENCE.FIVE_YEAR.value:
     params["exp"] = "5plus"
  else:
    del params["exp"]

  return build_url(base_url, **params)

def build_url_robota(language='', city='', **params):
  base_url = "https://robota.ua/zapros/"
  if language:
      base_url += quote(language).lower()
  if params["position"]:
      base_url += '-' + params["position"].lower()
      del params["position"]
  base_url += '/'
  if city == "remote":
      params["scheduleIds"] = 3
  elif city:
      base_url += city.lower() + '/'

  if params["experience"] == EXPERIENCE.WITHOUT_EXPERIENCE.value:
     params["experienceType"] = "true"
  params["experience"] = ""

  return build_url(base_url, **params)


def build_url_jooble(**params):
  base_url = "https://ua.jooble.org/SearchResult"

  if params["workExp"] == EXPERIENCE.STUDENT.value or params["workExp"] == EXPERIENCE.WITHOUT_EXPERIENCE.value:
    params["workExp"] = 1
  else:
    params["workExp"] = ""

  if params["rgns"] == "remote":
    params["loc"]=2
    params["rgns"] = ""
  return build_url(base_url, **params)


url = build_url_robota(
    language="c++",
    city="kyiv",
    position="junior",
    salary=20340,
    experience=0
)
print(url)

url = build_url_workua(
    language="c++",
    city="kyiv",
    #position="junior",
    #min_salary=20340,
    #experience=0,
    days=122
)
print(url)


url = build_url_djinni(
    all_keywords="python",
    primary_keyword="c#",
    region="UKR",
    location="Kyiv",
    exp_level=-2,
    exp_rank="junior",
    salary=convert_uah_to_usd_for_djinni(20, 39.1),
    keywords="c++"
)
print(url)

url = build_url_dou(city="remote", search="c++", position="junior", exp=1) #в доу можна скрапить і по 0-1 і по 1-3
print(url)

jooble_url = build_url_jooble(date=3, #щоб вакансії за останню неділлю
                              rgns="remote",
                              salaryMin="1000",
                              ukw="junior" + ' ' + "c++",
                              workExp=0
                              )
print(jooble_url)

__all__ = ('work', "robota", 'dou', 'djinni')

headers = [
    {'User-Agent': 'Mozilla/5.0 (Windows NT 5.1; rv:47.0) Gecko/20100101 Firefox/47.0',
        'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'},
    {'User-Agent': 'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36',
        'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'},
    {'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; rv:53.0) Gecko/20100101 Firefox/53.0',
        'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'}
    ]



def work(url, city=None, language=None):
    jobs = []
    errors = []
    domain = 'https://www.work.ua'
    if url:
        resp = requests.get(url, headers=headers[randint(0, 2)])
        if resp.status_code == 200:
            soup = BS(resp.content, 'html.parser')
            main_div = soup.find('div', id='pjax-job-list')
            if main_div:
                div_lst = main_div.find_all('div', attrs={'class': 'job-link'})
                # ігноруємо вакансії після p з текстом Вакансії, пов’язані із запитом «python junior» у Києві
                # Ініціалізація списку для зберігання дівів, які знаходяться перед вказаним тегом <p>
                target_p = soup.find('p', class_='text-default-7 add-bottom')

                result_divs = []
                if target_p:
                  for div in target_p.find_all_previous('div', class_='job-link'):
                      result_divs.append(div)
                else:
                  result_divs = div_lst


                for div in result_divs:
                    title = div.find('h2')
                    href = title.a['href']
                    content = div.p.text
                    description = re.sub(r'\s+', ' ', content).strip()
                    img_div = div.find('div', class_ = 'add-bottom')

                    spans = div.find_all('span',  class_='strong-600')
                    salary = '0'
                    company = ''
                    if len(spans)==2:
                      salary = spans[0].text
                      company = spans[1].text
                    else:
                      company = spans[0].text

                    if img_div:
                      img_tag = img_div.find('img')
                      if img_tag:  # Якщо тег <img> присутній
                          img_src = img_tag['src']
                      else:
                          img_src = 'https://st.work.ua/i/work-ua-knowledge-graph.jpg'

                    jobs.append({'title': title.text, 'img_source': img_src, 'url': domain + href,
                                 'description': description, 'company': company,
                                 'city_id': city, 'language_id': language,'salary': salary, 'site': "workua"})
            else:
                errors.append({'url': url, 'title': "Div does not exists"})
        else:
            errors.append({'url': url, 'title': "Page do not response"})

    return jobs, errors

def dou_image(url):
    image_src = ''
    if url:
        resp = requests.get(url, headers=headers[randint(0, 2)])
        if resp.status_code == 200:
            soup = BS(resp.content, 'html.parser')
            comp_div = soup.find('div', attrs={'class': 'b-compinfo'})
            if comp_div:
                a = comp_div.find('a', attrs={'class': 'logo'})
                image_src = a.img['src']

    return image_src


def dou(url, city=None, language=None):
    jobs = []
    errors = []

    if url:
        resp = requests.get(url, headers=headers[randint(0, 2)])
        if resp.status_code == 200:
            soup = BS(resp.content, 'html.parser')
            main_div = soup.find('div', id='vacancyListId')
            if main_div:
                li_lst = main_div.find_all('li', attrs={'class': 'l-vacancy'})
                for li in li_lst:
                    title = li.find('div', attrs={'class': 'title'})
                    href = title.a['href']
                    cont = li.find('div', attrs={'class': 'sh-info'})
                    content = cont.text
                    company = 'No name'
                    salary = '0'
                    a = title.find('a', attrs={'class': 'company'})
                    img_src = dou_image(href)
                    if a:
                        company = a.text
                    jobs.append({'title': title.text, 'img_source': img_src, 'url': href,
                                 'description': content, 'company': company,
                                 'city_id': city, 'language_id': language, 'salary': salary, 'site': "dou"})
            else:
                errors.append({'url': url, 'title': "Div does not exists"})
        else:
            errors.append({'url': url, 'title': "Page do not response"})

    return jobs, errors

def djinni(url, city=None, language=None):
    jobs = []
    errors = []
    domain = 'https://djinni.co'
    if url:
        resp = requests.get(url, headers=headers[randint(0, 2)])
        if resp.status_code == 200:
            soup = BS(resp.content, 'html.parser')
            main_ul = soup.find('ul',  attrs={'class': 'list-unstyled list-jobs mb-4'})
            if main_ul:
                li_lst = main_ul.find_all('li',
                                          attrs={'class': 'list-jobs__item'})
                for li in li_lst:
                    title_div = li.find('div',
                                    attrs={'class': 'job-list-item__title'})
                    if title_div:
                        title = title_div.a
                        href = title['href']

                    else:
                        print("Div з класом 'job-list-item__title' не знайдено.")

                    cont = li.find('div', attrs={'class': 'job-list-item__description'})
                    span = cont.find('span')
                    content = span.text
                    company = 'No name'
                    span_salary = li.find('span', attrs={'class': 'public-salary-item'})
                    if span_salary:
                        salary = span_salary.text
                    else:
                        salary='0'
                    comp = li.find('a', attrs={'class': 'mr-2'})

                    img_div = li.find('div', attrs={'class': 'userpic-wrapper userpic-color_2 userpic_xs userpic-transparent userpic--logo'})
                    if img_div:
                        img_src = img_div.img['src']
                    else:
                        img_src = 'https://sourcingsummit.net/sosutech/wp-content/uploads/sites/30/2017/07/djinnix505x235-1.jpg'

                    if comp:
                        company = comp.text

                    jobs.append({'title': title.text, 'img_source': img_src, 'url': domain+href,
                                 'description': content, 'company': company,
                                 'city_id': city, 'language_id': language, 'salary': salary, 'site': "djinni"})
            else:
                errors.append({'url': url, 'title': "Div does not exists"})
        else:
            errors.append({'url': url, 'title': "Page do not response"})

    return jobs, errors

def helper_robota(url):
    jobs = []
    errors = []
    domain = 'https://djinni.co'
    if url:
        resp = requests.get(url, headers=headers[randint(0, 2)])
        if resp.status_code == 200:
            soup = BS(resp.content, 'html.parser')
            main_ul = soup.find('ul',  attrs={'class': 'list-unstyled list-jobs mb-4'})
            if main_ul:
                li_lst = main_ul.find_all('li',
                                          attrs={'class': 'list-jobs__item'})
                for li in li_lst:
                    title_div = li.find('div',
                                    attrs={'class': 'job-list-item__title'})
                    if title_div:
                        title = title_div.a
                        href = title['href']

                    else:
                        print("Div з класом 'job-list-item__title' не знайдено.")

                    cont = li.find('div', attrs={'class': 'job-list-item__description'})
                    span = cont.find('span')
                    content = span.text
                    company = 'No name'
                    span_salary = li.find('span', attrs={'class': 'public-salary-item'})
                    if span_salary:
                        salary = span_salary.text
                    else:
                        salary='0'
                    comp = li.find('a', attrs={'class': 'mr-2'})

                    img_div = li.find('div', attrs={'class': 'userpic-wrapper userpic-color_2 userpic_xs userpic-transparent userpic--logo'})
                    if img_div:
                        img_src = img_div.img['src']
                    else:
                        img_src = 'https://sourcingsummit.net/sosutech/wp-content/uploads/sites/30/2017/07/djinnix505x235-1.jpg'

                    if comp:
                        company = comp.text

                    jobs.append({'title': title.text, 'img_source': img_src, 'url': domain+href,
                                 'description': content, 'company': company,
                                 'salary': salary, 'site': "robota"})
            else:
                errors.append({'url': url, 'title': "Div does not exists"})
        else:
            errors.append({'url': url, 'title': "Page do not response"})

    return jobs, errors

def robota(url, city=None, language=None):
    jobs = []
    errors = []
    domain = 'https://robota.ua'

    # Инициализация драйвера Chrome
    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument('--headless')
    chrome_options.add_argument('--no-sandbox')
    chrome_options.add_argument('--disable-dev-shm-usage')
    chrome_options.binary_location = 'chromedriver.exe'
    driver = webdriver.Chrome(options=chrome_options)

    try:
        driver.get(url)

        for i in range(10):
          driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
          time.sleep(2)  # Затримка між прокрутками

        # Затримка для завантаження додаткового вмісту
        time.sleep(5)

        # Отримання HTML-вмісту сторінки
        page_source = driver.page_source


        soup = BS(page_source, 'html.parser')

        # Поиск блоков с вакансиями
        job_divs = soup.find_all('alliance-vacancy-card-desktop')
        for job_div in job_divs:
            #print(job_div)
            a = job_div.find('a', class_='card')
            if a:
                href = a['href']
            else:
                href = ''

            title_tag = job_div.find('h2', class_='santa-typo-h3')
            if title_tag:
                title = title_tag.text.strip()
            else:
                title = ''

            spans = job_div.find_all('span', class_='ng-trigger')
            salary = '0'
            company = ''
            for span in spans:
                text = span.text.strip()
                if '₴' in text:  # Если в тексте есть символ валюты, предполагаем, что это зарплата
                    salary = text
                else:
                    company = text
                    break
            # изображение блокируется на сайте работа
            img_div = job_div.find('div', attrs={'class': 'company-logo'})
            img_src = 'https://play-lh.googleusercontent.com/mr-SZKDW5xmXOinA1cQWz6VeQ10BMKS_UfjGpSxrtoRAl9tNe6HPq5ALFCBAQE2Gw8A'
            if img_div:
                img_tag = img_div.find('img')
                if img_tag:
                    img_src = img_tag['src']

            content_divs = job_div.find_all('div', attrs={'class': 'badge'})
            content = ''
            if content_divs:
                for div in content_divs :
                    content += div.text + "."
                content += ".."
            if robota_help(driver, domain + href, language):
                jobs.append({'title': title, 'img_source': img_src, 'url': domain + href,
                            'description': content, 'company': company,
                            'city_id': city, 'language_id': language, 'salary': salary, 'site': "robota"})

    except Exception as e:
        errors.append({'url': url, 'title': str(e)})

    finally:
        # Закрытие браузера
        driver.quit()

    return jobs, errors

# url = 'https://robota.ua/zapros/java-junior/kyiv'
# print(url)
# jobs, errors = robota(url)
# print(jobs)
# print(errors)

def robota_help(driver, url, language):
    driver.get(url)
    # Отримання HTML-вмісту сторінки
    page_source = driver.page_source
    #print(page_source)

    soup = BS(page_source, 'html.parser')
    description = soup.find('div', class_='full-desc')
    if description:
        return contains_language(description.get_text(), language)
    else:
        return False

def contains_language(description, language):
    return language.lower() in description.lower()

robota(url="https://robota.ua/ru/zapros/c%2523/kyiv?position=junior&experience=1", city="Kyiv", language="C#")

def jooble(url, language=None):
    jobs = []
    errors = []
    if url:
        resp = requests.get(url, headers=headers[randint(0, 2)])
        if resp.status_code == 200:
            soup = BS(resp.content, 'html.parser')
            main_div = soup.find('div', class_='infinite-scroll-component ZbPfXY _serpContentBlock')
            if main_div:
                div_lst = main_div.find_all('div', attrs={'data-test-name': '_jobCard'})

                for div in div_lst:
                    a = div.find('a', class_='hyperlink_appearance_undefined')
                    href = a['href']
                    title = a.text
                    div_info = div.find('div', class_='slQ-DR')
                    salary = '0'
                    p_salary = div_info.find('p')
                    if p_salary:
                        salary = p_salary.text
                    description = div_info('div', class_='PAM72f')
                    div_title = div.find('div', class_='L4BhzZ')
                    p_company = div_title.find('p', class_='z6WlhX')
                    company=''
                    if p_company:
                        company = p_company.text
                    img = div_title.find('img')
                    if img:
                        img_src = img['src']
                    else:
                        img_src =  'https://play-lh.googleusercontent.com/JCQ1opom-Kay8f3xVs9VfKmDKsKD3md5uKLJf93gsYAawE6UpzgN_2fALgS0mKOcNw=s256-rw'
                    #print(jooble_help(href, language))
                    jobs.append({'title': title, 'img_source': img_src, 'url': href,
                                'description': description[0].text, 'company': company,
                                  'salary': salary, 'site': "jooble"})
            else:
                errors.append({'url': url, 'title': "Div does not exists"})
        else:
            errors.append({'url': url, 'title': "Page do not response"})

    return jobs, errors

# def jooble_help(url, language):
#     print(url)
#     resp = requests.get(url, headers=headers[randint(0, 2)])
#     print(resp)
#     if resp.status_code == 200:
#         soup = BS(resp.content, 'html.parser')
#         description = soup.find('div', class_='GDU7fA')
#         print("description", description)
#         if description:
#             return contains_language(description.get_text(), language)
#     else:
#         print(resp.content.decode())
#         return False

# jooble("https://ua.jooble.org/SearchResult?ukw=c%2B%2B", language="C++")

def format_vacancy(job):
    # Инициализация сообщения с заголовком вакансии
    vacancy_message = f"💼 <b>{job['title'].strip()}</b>\n\n"

    # Проверка и добавление компании
    if 'company' in job and job['company'].strip():
        vacancy_message += f"🏢 <b>Компанія:</b> {job['company'].strip()}\n\n"

    # Проверка и добавление зарплаты, если она не пустая и не равна '0'
    salary = job.get('salary', '')
    if salary and salary not in ['0', '']:
        vacancy_message += f"💵 <b>Зарплата:</b> {salary}\n\n"

    # Проверка и добавление описания вакансии
    description = job.get('description', '')
    if description.strip():
        vacancy_message += f"📝 <b>Опис вакансії:</b>\n{description.strip()}\n\n"

    # Добавление строки с информацией о кнопке
    vacancy_message += "<i>Щоб детальніше ознайомитися з вакансією, натисніть кнопку нижче:</i>"

    site = job.get('site', '')
    if site == 'workua':
        button_text = "Переглянути на Work.ua"
    elif site == 'robota':
        button_text = "Переглянути на Robota"
    elif site == 'djinni':
        button_text = "Переглянути на Djinni"
    elif site == 'jooble':
        button_text = "Переглянути на Jooble"
    elif site == 'dou':
        button_text = "Переглянути на DOU"
    else:
        button_text = "Переглянути"

    button = types.InlineKeyboardButton(text=button_text, url=job['url'])
    markup = types.InlineKeyboardMarkup().add(button)

    return vacancy_message, markup

def format_unique_vacancy(job):
    info = f"<b>{job['title']}</b>\n"
    if job['company']: info += f"<b>Компанія:</b> {job['company']}\n"
    info += f"<b>Технологія:</b> {job['technology']}\n"
    if job['position']: info += f"<b>Позиція:</b> {job['position']}\n"
    if job['city']: info += f"<b>Місто:</b> {job['city']}\n"

    if job['salary'] > 0:
        info += f"<b>Заробітна плата:</b> {job['salary']} грн\n"
    else:
        info += "<b>Заробітна плата:</b> не вказано\n"

    if job['description']:
        info += f"<b>Опис:</b> {job['description']}\n"

    if job['contact']:
        info += f"<b>Контакт:</b> {job['contact']}\n"
    return info

def send_job_offer_instructions(self, chat_id):
    instructions = """
    Наш бот надає можливість роботодавцям запропонувати свої унікальні вакансії. Ваша вакансія буде позначена як унікальна і матиме додаткову видимість для користувачів.

    <b>Обов'язкові поля для введення:</b>
    - 📌 Назва вакансії
    - 📂 Категорія
    - 📞 Контакт для зв'язку

    <b>Необов'язкові поля:</b>
    - 📝 Опис
    - 💰 Заробітна плата
    - 👔 Необхідний досвід роботи

    Ваша вакансія буде показуватись користувачам протягом 14 днів. Після цього її буде автоматично видалено. Ви також можете видалити вакансію у будь-який момент.

    Після надсилання, менеджер підтвердить вакансію або відхилить її із зазначенням причини.
    """
    self.bot.send_message(chat_id, instructions, parse_mode="HTML")

class STAGE(Enum):
  START = 0
  NEXT_PARAM_CITY = 1
  NEXT_PARAM_CATEGORY = 2
  NEXT_PARAM_POSITION = 3
  NEXT_PARAM_MIN_SALARY = 4
  NEXT_PARAM_EXPERIENCE = 5
  NEXT_PARAM_LANGUAGE = 6
  END_OF_PROFILE_FILLING = 7
  RECEIVING_VACANCIES = 8
  START_SEARCH = 9
  START_SEARCHING_FOR_NEW_VACANCIES = 10
  CREATE_REQUEST = 11
  MY_REQUESTS = 12
  PRICING = 13
  ABOUT_BOT = 14
  CONTACTS = 15
  CREATE_UNIQUE_VACANCY = 16
  CREATE_UV_ADD_JOB_TITLE = 17
  CREATE_UV_ADD_CATEGORY = 18
  CREATE_UV_NEXT_PARAM_CATEGORY = 19
  CREATE_UV_ADD_COMPANY_NAME = 20
  CREATE_UV_ADD_DESCRIPTION = 21
  CREATE_UV_ADD_SALARY = 22
  CREATE_UV_ADD_EXPERIENCE = 23
  CREATE_UV_ADD_CITY = 24
  CREATE_UV_ADD_CONTACT = 25
  CREATE_UV_ADD_POSITION = 26

class Request:
  def __init__(self, language='', city='', position='', min_salary=0, experience=EXPERIENCE.DEFAULT_VALUE.value):
    self.language = language
    self.city = city
    self.position = position
    self.min_salary = int(min_salary)
    self.experience = int(experience)

  def __str__(self):
    return (f"Request(Language: {self.language}, City: {self.city}, "
            f"Position: {self.position}, Min Salary: {self.min_salary}, "
            f"Experience: {self.experience})")

  def set_language(self, language):
    self.language = language

  def set_city(self, city):
    self.city = city

  def set_position(self, position):
    self.position = position

  def set_min_salary(self, min_salary):
    self.min_salary = int(min_salary)

  def set_experience(self, experience):
    self.experience = int(experience)


  def add_request_to_db(self, chat_id, db_manager):
    existing_request = db_manager.execute_query("SELECT * FROM requests WHERE chat_id = %s AND technology = %s AND position = %s AND city = %s AND min_salary = %s AND experience = %s", (chat_id, self.language, self.position, self.city, self.min_salary, self.experience))
    if not existing_request:
                db_manager.execute_query(f"UPDATE users SET num_of_used_request = num_of_used_request + 1 WHERE chat_id = {chat_id}")
                db_manager.execute_query("INSERT INTO requests (chat_id, technology, position, city, min_salary, experience) VALUES (%s, %s, %s, %s, %s, %s)", (chat_id, self.language, self.position, self.city, self.min_salary, self.experience))
    else:
      return False
    return True

def submit_vacancy(jobs, chat_id, is_unique_vacancy = False):
  for job in jobs:
    print(job)
    try:
        #print("job['img_source'] = ", job['img_source'])
        if is_unique_vacancy:
          caption_ = format_unique_vacancy(job)
          bot.send_photo(chat_id, job['img_source'], caption=caption_, parse_mode='HTML')
        else:
          caption_, markup_ = format_vacancy(job)
          bot.send_photo(chat_id, job['img_source'], caption=caption_, reply_markup=markup_, parse_mode='HTML')
    except ApiTelegramException as e:
        print(f"An error occurred while sending the photo: {e}. URL: {job['img_source']}. Skip vacancy.")

def start_seach_and_send_unique_vacancy(request:Request, chat_id, on_the_background:bool = False):
    unique_vacancies = get_unique_vacancies_from_db(request)
    print(unique_vacancies)
    if not on_the_background:
        add_vacancies_to_db(request, chat_id, unique_vacancies, "unique")
        submit_vacancy(unique_vacancies, chat_id, is_unique_vacancy = True)
    else:
      return unique_vacancies

def start_seach_and_send_workua_vacancy(request:Request, chat_id, on_the_background:bool = False):
    if not on_the_background: days = 125 #вакансії за останній місяць
    else: days = 122 #вакансії за останній день
    url_work = build_url_workua(
            language=request.language,
            city=request.city, #ТУТ ПОХОДУ УКРАЇНСЬКОЮ НЕ МОЖНА, ТРЕБА ВИПРАВИТИ
            position=request.position,
            min_salary=request.min_salary,
            experience=request.experience,
            days=days
    )
    print("WORKUA URL: ", url_work)
    jobs_work, errors_work = work(url_work)
    print(jobs_work)
    print(errors_work)
    if not on_the_background:
      add_vacancies_to_db(request, chat_id, jobs_work, "workua")
      submit_vacancy(jobs_work, chat_id)
    else:
      return jobs_work, errors_work

def start_seach_and_send_dou_vacancy(request:Request, chat_id, on_the_background:bool = False):
    url_dou = build_url_dou(search=request.language, position=request.position, city=request.city, exp=request.experience ) #в доу можна скрапить і по 0-1 і по 1-3, тоже нужно решить проблему
    print("DOU URL: ", url_dou)
    jobs_dou, errors_dou = dou(url_dou)
    print(jobs_dou)
    print(errors_dou)
    if not on_the_background:
      add_vacancies_to_db(request, chat_id, jobs_dou, "dou")
      submit_vacancy(jobs_dou, chat_id)
    else:
      return jobs_dou, errors_dou

def start_seach_and_send_djinni_vacancy(request:Request, chat_id, on_the_background:bool = False):
    url_djinni = build_url_djinni(
      #all_keywords=request.language,
      primary_keyword=request.language,
      region="UKR",
      location=request.city,
      exp_level=request.experience,
      exp_rank=request.position,
      salary=convert_uah_to_usd_for_djinni(request.min_salary, 39.1),
      keywords=request.language
    )
    print("DJINNI URL: ", url_djinni)
    jobs_djinni, errors_djinni = djinni(url_djinni)
    add_vacancies_to_db(request, chat_id, jobs_djinni, "djinni")
    print(jobs_djinni)
    print(errors_djinni)
    if not on_the_background:
      submit_vacancy(jobs_djinni, chat_id)
    else:
      return jobs_djinni, errors_djinni

def start_seach_and_send_robota_vacancy(request:Request, chat_id, on_the_background:bool = False):
    url_robota=build_url_robota(language=request.language, city=request.city, position=request.position, salary = request.min_salary, experience=request.experience)
    print("ROBOTA URL: ", url_robota)
    jobs_rabota, errors_robota = robota(url_robota, language=request.language)
    print(jobs_rabota)
    print(errors_robota)
    if not on_the_background:
      add_vacancies_to_db(request, chat_id, jobs_rabota, "robota")
      submit_vacancy(jobs_rabota, chat_id)
    else:
      return jobs_rabota, errors_robota

def start_seach_and_send_jooble_vacancy(request:Request, chat_id, on_the_background:bool = False):
    if not on_the_background: date = 3 #вакансії за останню неділлю
    else: date = 8 #вакансії за останній день
    url_jooble = build_url_jooble(date=date,
                                  rgns=request.city,
                                  salaryMin=request.min_salary,
                                  ukw=request.position + ' ' + request.language,
                                  workExp=request.experience
                                 )
    print("JOOBLE URL: ", url_jooble)
    jobs_jooble, errors_jooble = jooble(url_jooble)
    print(jobs_jooble)
    print(errors_jooble)
    if not on_the_background:
      add_vacancies_to_db(request, chat_id, jobs_jooble, "jooble")
      submit_vacancy(jobs_jooble, chat_id)
    else:
      return jobs_jooble, errors_jooble

def check_db_has_such_vacancy(request_id, site, title, company):
    # Проверяем, существует ли уже такая вакансия в базе данных
    check_query = """
        SELECT COUNT(*) FROM vacancies
        WHERE request_id = %s AND site = %s AND title = %s AND company = %s
        """
    check_params = (request_id, site, title, company)
    check_result = db_manager.execute_query(check_query, check_params)
    if check_result[0][0] == 0:
      return False
    else:
      return True

def add_NEW_vacancy_to_db(request_id, site, title, company, description):
    insert_query = """
                    INSERT INTO vacancies (request_id, site, title, company, description) VALUES(%s, %s, %s, %s, %s)
                    """
    insert_params = (request_id, site, title, company, description)
    insert_result = db_manager.execute_query(insert_query, insert_params)
    return insert_result

def add_vacancies_to_db(request: Request, chat_id, vacancies, site):
    query = """
        SELECT request_id FROM requests
        WHERE chat_id = %s AND technology = %s AND position = %s AND city = %s AND min_salary = %s AND experience = %s
        """
    params = (chat_id, request.language, request.position, request.city, request.min_salary, request.experience)
    result = db_manager.execute_query(query, params)

    if result:
        for vacancy in vacancies:#[:5]:  # Обрабатываем только первые 5 вакансий. НЕТ. ПОКА ЧТО будем добавлять ВСЕ вакансии в дб, чтобы потом не было проблем
            db_has_such_vacancy = check_db_has_such_vacancy(result[0][0], site, vacancy['title'],  (vacancy['company'] or '').strip())
            # Если вакансия не найдена, добавляем её в базу данных
            if db_has_such_vacancy == False:  # Проверяем, что вакансия в бд не найдена
                insert_result = add_NEW_vacancy_to_db(result[0][0], site, vacancy['title'], (vacancy['company'] or '').strip(), vacancy.get('description', ''))
                print("Вакансия добавлена:", insert_result)
            else:
                print("Вакансия уже существует в базе данных")

def process_vacancy(vacancy, request_item, is_unique_vacancy = False):
  print("vacancy: ", vacancy)
  if check_db_has_such_vacancy(request_item[0], vacancy['site'], vacancy['title'], (vacancy['company'] or '').strip()) == False:
    print("Find new vacancy! Add to db and submit to chat")
    insert_result = add_NEW_vacancy_to_db(request_item[0], vacancy['site'], vacancy['title'], (vacancy['company'] or '').strip(), vacancy.get('description', ''))
    print("Вакансия добавлена:", insert_result)
    submit_vacancy([vacancy], int(request_item[1]), is_unique_vacancy) #request_item[1] - це chat_id
  else:
    print("This vacancy is already in the database")
    #bot.send_message(request_item[1], "Nothing new. I'm working...")

import schedule
import time

class JobScheduler:
    def __init__(self, db_manager):
        self.db_manager = db_manager
        self.keep_running = False

    def job(self):
        print("Start working on background")
        requests_from_db = self.db_manager.get_requests_from_db()
        for request_item in requests_from_db:
          request_from_db = Request(language=request_item[2], city=request_item[4], position=request_item[3], min_salary=request_item[5], experience=request_item[6])
          print(request_from_db)
          print("Start searching on background")
          unique_vacancies = start_seach_and_send_unique_vacancy(request_from_db, 0, on_the_background = True)
          jobs_work, errors_work = start_seach_and_send_workua_vacancy(request_from_db, 0, on_the_background = True)
          # jobs_dou, errors_dou = start_seach_and_send_dou_vacancy(request_from_db, 0, on_the_background = True)
          # jobs_djinni, errors_djinni = start_seach_and_send_djinni_vacancy(request_from_db, 0, on_the_background = True)
          # jobs_rabota, errors_robot = start_seach_and_send_robota_vacancy(request_from_db, 0, on_the_background = True)
          # jobs_jooble, errors_jooble = start_seach_and_send_jooble_vacancy(request_from_db, 0, on_the_background = True)
          print("End searching on background")

          vacancies = list(chain(jobs_work))#, jobs_dou, jobs_djinni, jobs_rabota, jobs_jooble))
          #vacancies = [jobs_work]#, jobs_dou, jobs_djinni, jobs_rabota, jobs_jooble]
          print("Start checking finding vacancies")
          for vacancy in unique_vacancies:
              process_vacancy(vacancy, request_item, is_unique_vacancy=True)
          for vacancy in vacancies:
              process_vacancy(vacancy, request_item)
          print("End checking finding vacancies")

    def start_scheduler(self):
        self.keep_running = True

    def stop_scheduler(self):
        self.keep_running = False

    def run_scheduler(self):
        schedule.every(1).minutes.do(self.job)
        print("start run_scheduler. keep_running = ", self.keep_running)
        while self.keep_running:
            schedule.run_pending()
            time.sleep(1)

def get_subscription_info(chat_id):
    result = db_manager.execute_query("SELECT paid_subscription FROM users WHERE chat_id = %s", (chat_id,))
    if result:
        subscription_level = result[0][0]
        if subscription_level == 0:
            return "Ви ще не обрали жодного тарифу."
        elif subscription_level == 1:
            return "Ваш поточний тариф: 🔴 Економ."
        elif subscription_level == 2:
            return "Ваш поточний тариф: 🟠 Стандарт."
        elif subscription_level == 3:
            return "Ваш поточний тариф: 🟢 Бізнес."
    else:
        return "Ви ще не обрали жодного тарифу."

class UniqueVacancy:
    def __init__(self, title="", company="", category="", description="", salary=0, position="", experience=0, city="", contact="", status="active", photo=None):
        self.title = title
        self.company = company
        self.category = category
        self.description = description
        self.salary = salary
        self.position = position
        self.experience = experience
        self.city = city
        self.contact = contact
        self.status = status  # По замовчуванню вакансія активна
        self.photo = photo  # Зображення вакансії (якщо є)

    def set_title(self, title):
        if not title:
            raise ValueError("Назва вакансії не може бути порожньою.")
        self.title = title

    def set_company(self, company):
        self.company = company

    def set_category(self, category):
        self.category = category

    def set_description(self, description):
        self.description = description

    def set_position(self, position):
        self.position = position

    def set_salary(self, salary):
        self.salary = salary

    def set_experience(self, experience):
        self.experience = experience

    def set_city(self, city):
        self.city = city

    def set_contact(self, contact):
        self.contact = contact

    def set_status(self, status):
        self.status = status

    def __str__(self):
        info = f"Назва вакансії: {self.title}\n"
        info += f"Назва компанії: {self.company}\n"
        info += f"Категорія: {self.category}\n"
        info += f"Опис: {self.description}\n"
        info += f"Заробітня плата: {self.salary}\n"
        info += f"Позиція: {self.position}\n"
        info += f"Досвід роботи: {self.experience}\n"
        info += f"Місто: {self.city}\n"
        info += f"Контакт: {self.contact}\n"
        info += f"Статус: {self.status}\n"
        if self.photo:
            info += "Зображення: Додано\n"
        else:
            info += "Зображення: Не додано\n"
        return info

    def to_dict(self):
        end_date = datetime.now().date() + relativedelta(days=14)
        return {
            "technology": self.category,
            "position": self.position,
            "city": self.city,
            "salary": self.salary,
            "experience": self.experience,
            "title": self.title,
            "company": self.company,
            "description": self.description,
            "contact": self.contact,
            "end_date": end_date
        }

    def add_unique_vacancy_to_db(self):
        insert_query = """
                        INSERT INTO unique_vacancies (technology, position, city, salary, experience, title, company, description, contacts, end_date)
                        VALUES(%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                        """
        end_date = datetime.now().date() + relativedelta(days=14)
        insert_params = (self.category, self.position, self.city, self.salary, self.experience, self.title, self.company, self.description, self.contact, end_date)
        insert_result = db_manager.execute_query(insert_query, insert_params)

        if not insert_result:
          select_query = """
                    SELECT vacancy_id
                    FROM unique_vacancies
                    WHERE title = %s AND technology = %s AND position = %s AND salary =  = %s AND description = %s
                    """
          select_params = (self.title, self.category, self.position, self.salary, self.description)
          return db_manager.execute_query(select_query, select_params)[0][0]
        return insert_result

def get_unique_vacancies_from_db(request):
  query = f"SELECT * FROM unique_vacancies \
            WHERE technology = '{request.language}' "
  if request.position : query+= f"and (position = '{request.position}' or position is null) "
  if request.city : query+= f"and (city = '{request.city}' or city is null) "
  if request.min_salary : query+= f"and (salary > {request.min_salary} or salary = 0) "
  if request.experience != EXPERIENCE.DEFAULT_VALUE.value : query+= f"and (experience = {request.experience} or experience = -2)";
  #print(query)
  result = db_manager.execute_query(query)
  print(result)
  formatted_vacancies = []
  for vacancy in result:
    #print(vacancy)
    vacancy_dict = {
            'technology': vacancy[1],
            'position': vacancy[2],
            'city': vacancy[3],
            'salary': vacancy[4],
            'experience': vacancy[5],
            'title': vacancy[6],
            'company': vacancy[7],
            'description': vacancy[8],
            'contact': vacancy[10],
            'img_source': vacancy[9],
            'site': "unique"
        }
    formatted_vacancies.append(vacancy_dict)
  return formatted_vacancies

class AdminManager:
    def __init__(self, db_manager):
        self.db_manager = db_manager

    def is_admin(self, chat_id):
        result = db_manager.execute_query(f"SELECT * FROM admins WHERE admin_id = {chat_id}")
        if not result:
          return False
        return True

    def get_main_admin_id(self):
        result = db_manager.execute_query("SELECT admin_id FROM admins")
        return result[0][0]

class UserManager:
    def __init__(self, db_manager):
        self.db_manager = db_manager

    def check_and_new_add_user_to_db(self, chat_id):
        result = db_manager.execute_query(f"SELECT * FROM users WHERE chat_id = {chat_id}")
        if not result:
          db_manager.execute_query(f"INSERT INTO users (chat_id, paid_subscription, max_num_of_request, num_of_used_request) VALUES ({chat_id}, 0, 2, 0);")

    def user_can_create_request(self, chat_id):
      user_info = db_manager.execute_query(f"SELECT num_of_used_request, max_num_of_request FROM users WHERE chat_id = {chat_id}")
      if user_info:
          num_of_used_request, max_num_of_request = user_info[0]
          if num_of_used_request >= max_num_of_request:
              return False
          else:
            return True
      return False

    def get_stage(self, chat_id):
        query = f"SELECT stage FROM users WHERE chat_id = '{chat_id}' "
        result = db_manager.execute_query(query)
        return result[0][0]

    def set_stage(self, chat_id, stage):
        result = db_manager.execute_query(f"UPDATE users SET stage = {stage} WHERE chat_id = {chat_id}")

# user_manager = UserManager(db_manager)
# print(user_manager.get_stage(535434829))
# user_manager.set_stage(535434829, 0)

class BotManager:
    def __init__(self, token, payments_token, db_manager, user_manager, admin_manager):
        self.bot = telebot.TeleBot(token)
        self.payments_token = payments_token
        self.db_manager = db_manager
        self.db_manager.execute_query("UPDATE users SET stage = 0")
        self.user_manager = user_manager
        self.admin_manager = admin_manager
        self.users_vacancies = {}
        self.users_requests = {}
        self.setup_handlers()

    def run(self):
        self.bot.polling(none_stop=True, interval=0)

    def setup_handlers(self):
        self.bot.message_handler(commands=['start'])(self.start)
        self.bot.message_handler(commands=['pay1'])(self.pay1_command)
        self.bot.message_handler(commands=['pay2'])(self.pay2_command)
        self.bot.message_handler(commands=['pay3'])(self.pay3_command)
        self.bot.message_handler(content_types=['text'])(self.handle_text)
        self.bot.callback_query_handler(func=lambda call: call.data.startswith('delete_request_'))(self.delete_request)
        self.bot.callback_query_handler(func=lambda call: call.data.startswith('delete_new_unique_vacancy_'))(self.delete_new_unique_vacancy)
        self.bot.callback_query_handler(func=lambda call: call.data.startswith('approve_new_unique_vacancy_'))(self.approve_new_unique_vacancy)
        self.bot.callback_query_handler(func=lambda call: call.data.startswith('delete_unique_vacancy_'))(self.delete_unique_vacancy)
        self.bot.pre_checkout_query_handler(func=lambda query: True)(self.pre_checkout_query)
        self.bot.message_handler(content_types=['successful_payment'])(self.successful_payment)

    def show_main_menu(self, user_id):
        markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)

        item1 = types.KeyboardButton("📝 Створити запит")
        item2 = types.KeyboardButton("📋 Мої запити")
        item3 = types.KeyboardButton("💳 Тарифи та Оплата")
        item4 = types.KeyboardButton("ℹ️ Про бот")
        item5 = types.KeyboardButton("💼 Запропонувати вакансію")
        item6 = types.KeyboardButton("📞 Контакти")

        markup.add(item1, item2, item3, item4, item5, item6)

        self.bot.send_message(user_id, "Оберіть наступну дію:", reply_markup=markup)

    def show_create_UV_required_fields_menu(self, user_id):
        mandatory_markup = telebot.types.ReplyKeyboardMarkup(row_width=3, resize_keyboard=True, one_time_keyboard=True)

        item1 = telebot.types.KeyboardButton("Додати назву вакансії")
        item2 = telebot.types.KeyboardButton("Додати категорію")
        item3 = telebot.types.KeyboardButton("Додати контакт для зв'язку")
        item4 = telebot.types.KeyboardButton("⬅️")
        item5 = telebot.types.KeyboardButton("➡️")

        mandatory_markup.add(item1,item2, item3)
        mandatory_markup.add(item4, item5)

        # Надсилання повідомлення з клавіатурою
        self.bot.send_message(user_id, "Оберіть обов'язкове поле для заповнення:", reply_markup=mandatory_markup)

    def show_create_UV_optional_fields_menu(self, user_id):
        mandatory_markup = telebot.types.ReplyKeyboardMarkup(row_width=3, resize_keyboard=True, one_time_keyboard=True)

        item1 = telebot.types.KeyboardButton("Додати назву компанії")
        item2 = telebot.types.KeyboardButton("Додати позицію")
        item3 = telebot.types.KeyboardButton("Додати опис вакансії")
        item4 = telebot.types.KeyboardButton("Додати заробітню плату")
        item5 = telebot.types.KeyboardButton("Додати місто роботи")
        item6 = telebot.types.KeyboardButton("Додати досвід роботи")
        item7 = telebot.types.KeyboardButton("Повернутись назад")
        item8 = telebot.types.KeyboardButton("✅Готово")

        mandatory_markup.add(item1, item2, item3, item4, item5, item6, item7, item8)

        self.bot.send_message(user_id, "Оберіть необов'язкове поле для заповнення:",  reply_markup=mandatory_markup)

    def generate_keyboard(self, options, button_size):
       keyboard_rows = []
       for i in range(0, len(options), button_size):
            keyboard_rows.append(options[i:i + button_size])
       markup = ReplyKeyboardMarkup(row_width=button_size, resize_keyboard=True)
       for row in keyboard_rows:
            markup.row(*[KeyboardButton(option) for option in row])

       return markup

    def start(self, message):
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        # btn1 = types.KeyboardButton("Почати пошук роботи")
        # markup.add(btn1)
        self.bot.send_message(message.from_user.id, "👋 Привіт! Вас вітає бот з пошуку роботи!", reply_markup=markup)
        self.show_main_menu(message.from_user.id)
        self.user_manager.set_stage(message.from_user.id, STAGE.START.value)


    def show_create_request_menu(self, user_id):
        self.bot.send_message(user_id, "Оберіть параметр для пошуку:", reply_markup=self.generate_keyboard(["📂 Категорія", "🏙 Місто", "💼 Позиція", "⏳ Досвід роботи", "💰 Зарплата", "🔍 Почати пошук!"], 2))

    def pre_checkout_query(self, pre_checkout_query):
        try:
           self.bot.answer_pre_checkout_query(pre_checkout_query.id, ok=True)
        except Exception as e:
            print(f"Error handling pre_checkout_query: {e}")

    def successful_payment(self, message):
        payment_info = message.successful_payment
        payment_details = (f"Chat id: {message.chat.id}\n"
                           f"Currency: {payment_info.currency}\n"
                           f"Total amount: {payment_info.total_amount / 100:.2f} {payment_info.currency}\n"
                           f"Invoice payload: {payment_info.invoice_payload}")
        print("SUCCESSFUL PAYMENT:", payment_details)
        self.bot.send_message(message.chat.id, f"Платіж на суму {payment_info.total_amount / 100:.2f} {payment_info.currency} пройшов успішно.")

        if payment_info.invoice_payload == "🔴 Економ":
            self.pay1_payment_end(message.chat.id)
        elif payment_info.invoice_payload == "🟠 Стандарт":
            self.pay2_payment_end(message.chat.id)
        elif payment_info.invoice_payload == "🟢 Бізнес":
            self.pay3_payment_end(message.chat.id)

    def pay1_command(self, message):
        prices = [types.LabeledPrice(label="🔴 Економ", amount=4000)]
        self.bot.send_invoice(
            chat_id=message.chat.id,
            title="🔴 Економ",
            description="""Створюйте до двох(2) пошукових запитів вакансій на місяць. \nТариф активується автоматично одразу після оплати та триває протягом одного календарного місяця. \nОплачуючи Ви погоджуєтесь з Умовами Користування.""",
            provider_token=self.payments_token,
            currency='UAH',
            photo_url="https://www.aroged.com/wp-content/uploads/2022/06/Telegram-has-a-premium-subscription.jpg", # Фото можна змінити
            photo_width=416,
            photo_height=234,
            photo_size=416,
            is_flexible=False,
            prices=prices,
            max_tip_amount=20000,
            suggested_tip_amounts=[1000, 5000, 10000],
            start_parameter='time-machine-subs',
            invoice_payload='🔴 Економ'
        )

    def pay2_command(self, message):
        prices = [types.LabeledPrice(label="🟠 Стандарт", amount=8000)]
        self.bot.send_invoice(
            chat_id=message.chat.id,
            title="🟠 Стандарт",
            description="""Створюйте до чотирьох(4) пошукових запитів вакансій на місяць. \nТариф активується автоматично одразу після оплати та триває протягом одного календарного місяця. \nОплачуючи Ви погоджуєтесь з Умовами Користування.""",
            provider_token=self.payments_token,
            currency='UAH',
            photo_url="https://www.aroged.com/wp-content/uploads/2022/06/Telegram-has-a-premium-subscription.jpg", # Фото можна змінити
            photo_width=416,
            photo_height=234,
            photo_size=416,
            is_flexible=False,
            prices=prices,
            max_tip_amount=20000,
            suggested_tip_amounts=[1000, 5000, 10000],
            start_parameter='time-machine-subs',
            invoice_payload='🟠 Стандарт'
        )

    def pay3_command(self, message):
        prices = [types.LabeledPrice(label="🟢 Бізнес", amount=20000)]
        self.bot.send_invoice(
            chat_id=message.chat.id,
            title="🟢 Бізнес",
            description="""Створюйте до десяти(10) пошукових запитів вакансій на місяць. \nТариф активується автоматично одразу після оплати та триває протягом одного календарного місяця. \nОплачуючи Ви погоджуєтесь з Умовами Користування.""",
            provider_token=self.payments_token,
            currency='UAH',
            photo_url="https://www.aroged.com/wp-content/uploads/2022/06/Telegram-has-a-premium-subscription.jpg", # Фото можна змінити
            photo_width=416,
            photo_height=234,
            photo_size=416,
            is_flexible=False,
            prices=prices,
            max_tip_amount=20000,
            suggested_tip_amounts=[1000, 5000, 10000],
            start_parameter='time-machine-subs',
            invoice_payload='🟢 Бізнес'
        )

    def pay1_payment_end(self, chat_id):
        end_date_subscription = get_end_subscription_date()
        self.db_manager.execute_query("UPDATE users SET paid_subscription = 1, max_num_of_request = 2, end_date_subscription = %s WHERE chat_id = %s", (end_date_subscription, chat_id))
        self.bot.send_message(chat_id, "Ваш поточний тариф змінено на Економ.")

    def pay2_payment_end(self, chat_id):
        end_date_subscription = get_end_subscription_date()
        self.db_manager.execute_query("UPDATE users SET paid_subscription = 2, max_num_of_request = 4, end_date_subscription = %s WHERE chat_id = %s", (end_date_subscription, chat_id))
        self.bot.send_message(chat_id, "Ваш поточний тариф змінено на Стандарт.")

    def pay3_payment_end(self, chat_id):
        end_date_subscription = get_end_subscription_date()
        self.db_manager.execute_query("UPDATE users SET paid_subscription = 3, max_num_of_request = 10, end_date_subscription = %s WHERE chat_id = %s", (end_date_subscription, chat_id))
        self.bot.send_message(chat_id, "Ваш поточний тариф змінено на Бізнес.")

    def show_user_requests(self, chat_id):
        query = "SELECT * FROM requests WHERE chat_id = %s"
        params = (chat_id,)
        user_requests = self.db_manager.execute_query(query, params)

        if user_requests:
            for i, req in enumerate(user_requests, start=1):
                request_text = f"""
    <b>🔍 Номер запиту:</b> {i} \n
"""

                if req[2]:
                    request_text += f"<b>📂 Категорія:</b> {req[2]}\n"
                if req[3]:
                    request_text += f"<b>💼 Позиція:</b> {req[3]}\n"
                if req[4]:
                    request_text += f"<b>🏙 Місто:</b> {req[4]}\n"
                if req[5] != 0:
                    request_text += f"<b>💰 Мінімальна заробітна плата:</b> {req[5]}\n"
                if req[6] != -2:
                    if req[6] == -1:
                        request_text += "<b>🕒 Досвід роботи:</b> Студент\n"
                    else:
                        request_text += f"<b>🕒 Досвід роботи:</b> {req[6]} років\n"

                # Додавання пояснення
                request_text += "\n<i>Якщо ви бажаєте видалити свій запит, натисніть кнопку нижче.</i>\n"

                # Створюємо InlineKeyboardButton для кожного запиту з кнопкою "Видалити"
                button = types.InlineKeyboardButton(text="❌ Видалити", callback_data=f"delete_request_{req[0]}")
                markup = types.InlineKeyboardMarkup().add(button)
                self.bot.send_message(chat_id, request_text, reply_markup=markup, parse_mode="HTML")
        else:
             no_requests_text = """
                <b>Ви ще не створили жодного запиту.</b> \n \nДля того, щоб створити запит, натисніть кнопку <b>Створити запит</b> в меню."""
             self.bot.send_message(chat_id, no_requests_text, parse_mode="HTML")

    def delete_request(self, call):
        request_id = int(call.data.split('_')[-1])
        self.db_manager.execute_query("UPDATE users SET num_of_used_request = num_of_used_request - 1 WHERE chat_id = %s", (call.from_user.id,))
        self.db_manager.execute_query("DELETE FROM requests WHERE request_id = %s", (request_id,))
        self.bot.answer_callback_query(call.id, "Запит видалено успішно.")
        self.bot.delete_message(chat_id=call.from_user.id, message_id=call.message.message_id)

    def delete_unique_vacancy(self, call):
        unique_vacancy_id = int(call.data.split('_')[-1])
        print(unique_vacancy_id)

    def send_new_vacancy_to_admin(self, chat_id):
        button_delete = types.InlineKeyboardButton(text="Видалити", callback_data=f"delete_new_unique_vacancy_{chat_id}")
        button_approve = types.InlineKeyboardButton(text="Затвердити", callback_data=f"approve_new_unique_vacancy_{chat_id}")
        markup = types.InlineKeyboardMarkup().add(button_delete, button_approve)
        self.bot.send_message(self.admin_manager.get_main_admin_id(), self.users_vacancies.get(chat_id), reply_markup=markup)

    def delete_new_unique_vacancy(self, call):
        chat_id = int(call.data.split('_')[-1])
        self.bot.send_message(chat_id, "На жаль, ваша вакансія:\n\n" + str(self.users_vacancies.get(chat_id)) + "\nНе пройшла модерування")
        del self.users_vacancies[chat_id]
        self.bot.edit_message_reply_markup(chat_id=self.admin_manager.get_main_admin_id(), message_id=call.message.message_id, reply_markup=None)
        self.bot.send_message(self.admin_manager.get_main_admin_id(), "Вакансію видалено.")

    def approve_new_unique_vacancy(self, call):
        chat_id = int(call.data.split('_')[-1])
        result = self.users_vacancies.get(chat_id).add_unique_vacancy_to_db()
        self.bot.send_message(chat_id, "Вітаємо, ваша вакансія пройшла модерування і вже додана до унікальних вакансій!\n Вакансія має такий вигляд")
        print("result", result)
        if result:
            button = types.InlineKeyboardButton(text="❌ Видалити", callback_data=f"delete_unique_vacancy_{result}")
            markup = types.InlineKeyboardMarkup().add(button)
            self.bot.send_photo(chat_id, "https://i.ibb.co/ZW5P5PB/hot-vacancy.jpg", reply_markup=markup, caption=format_unique_vacancy(self.users_vacancies.get(chat_id).to_dict()), parse_mode='HTML')
        self.bot.edit_message_reply_markup(chat_id=self.admin_manager.get_main_admin_id(), message_id=call.message.message_id, reply_markup=None)
        self.bot.send_message(self.admin_manager.get_main_admin_id(), "Вакансію затверджено і додано в DB.")
        del self.users_vacancies[chat_id]


    def handle_text(self, message):
        self.user_manager.check_and_new_add_user_to_db(message.from_user.id) #threading.Thread(target=check_and_new_add_user_to_db, args=(message.from_user.id, )).start()
        stage = STAGE(self.user_manager.get_stage(message.from_user.id))

        if message.text == "🔍 Почати пошук!" and stage==STAGE.CREATE_REQUEST:
            if self.users_requests.get(message.from_user.id).language == "":
              self.bot.send_message(message.from_user.id, "Будь ласка, вкажіть категорію для пошуку (мову програмування)!")
              self.bot.send_message(message.from_user.id, "Оберіть категорію:", reply_markup=self.generate_keyboard(categories, 3))
              self.user_manager.set_stage(message.from_user.id, STAGE.NEXT_PARAM_CATEGORY.value)
            else:
              self.user_manager.set_stage(message.from_user.id, STAGE.START_SEARCH.value)

        if message.text == "Повернутися в головне меню" or message.text == "⬅️":
            self.user_manager.set_stage(message.from_user.id, STAGE.START.value)
            self.show_main_menu(message.from_user.id)
        else:
            stage = STAGE(self.user_manager.get_stage(message.from_user.id))
            print("stage = ", stage)
            handlers = {
                STAGE.START: self.handle_start,
                STAGE.CREATE_REQUEST: self.handle_create_request,
                STAGE.NEXT_PARAM_CATEGORY: self.handle_next_param_category,
                STAGE.NEXT_PARAM_LANGUAGE: self.handle_next_param_language,
                STAGE.NEXT_PARAM_CITY: self.handle_next_param_city,
                STAGE.NEXT_PARAM_POSITION: self.handle_next_param_position,
                STAGE.NEXT_PARAM_EXPERIENCE: self.handle_next_param_experience,
                STAGE.NEXT_PARAM_MIN_SALARY: self.handle_next_param_min_salary,
                STAGE.CREATE_UNIQUE_VACANCY: self.handle_create_unique_vacancy,
                STAGE.CREATE_UV_NEXT_PARAM_CATEGORY: self.handle_create_uv_next_param_category,
                STAGE.CREATE_UV_ADD_JOB_TITLE: self.handle_create_uv_add_job_title,
                STAGE.CREATE_UV_ADD_CATEGORY: self.handle_create_uv_add_category,
                STAGE.CREATE_UV_ADD_COMPANY_NAME: self.handle_create_uv_add_company_name,
                STAGE.CREATE_UV_ADD_DESCRIPTION: self.handle_create_uv_add_description,
                STAGE.CREATE_UV_ADD_SALARY: self.handle_create_uv_add_salary,
                STAGE.CREATE_UV_ADD_EXPERIENCE: self.handle_create_uv_add_experience,
                STAGE.CREATE_UV_ADD_CITY: self.handle_create_uv_add_city,
                STAGE.CREATE_UV_ADD_CONTACT: self.handle_create_uv_add_contact,
                STAGE.CREATE_UV_ADD_POSITION: self.handle_create_uv_add_position,
                STAGE.START_SEARCH: self.start_search,
            }
            handler = handlers.get(stage, self.handle_default)
            handler(message)

    def handle_default(self, message):
        self.bot.send_message(message.from_user.id, "Спробуйте ввести іншу команду. Введіть /start.") #TODO: кудись перемістити, ця частина не працює

    def handle_start(self, message):
        if message.text == "📋 Мої запити":
            self.user_manager.set_stage(message.from_user.id, STAGE.MY_REQUESTS.value)
            self.show_user_requests(message.from_user.id)
            self.user_manager.set_stage(message.from_user.id, STAGE.START.value)
        elif message.text == "📝 Створити запит":
            if self.user_manager.user_can_create_request(message.from_user.id):
              self.show_create_request_menu(message.from_user.id)
              self.user_manager.set_stage(message.from_user.id, STAGE.CREATE_REQUEST.value)
            else:
              self.bot.send_message(message.from_user.id, "Ви вичерпали ліміт запитів. Зверніться за передплатою.")
        elif message.text == "💳 Тарифи та Оплата":
           subscription_info = get_subscription_info(message.from_user.id)
           self.bot.send_message(message.from_user.id, f"""
                        Ваш поточний тариф: {subscription_info}

                        Хочете мати більше можливостей у використанні нашого бота? Оберіть один з доступних тарифів:

                        🔴 Економ
                        - Дозволяє створювати до двох запитів для пошуку вакансій на місяць
                        - Ціна: $1 на місяць
                        - Для замовлення тарифу використайте команду /pay1

                        🟠 Стандарт
                        - Дозволяє створювати до чотирьох запитів для пошуку вакансій на місяць
                        - Ціна: $2 на місяць
                        - Для замовлення тарифу використайте команду /pay2

                        🟢 Бізнес
                        - Дозволяє створювати до десяти запитів для пошуку вакансій на місяць
                        - Ціна: $5 на місяць
                        - Для замовлення тарифу використайте команду /pay3

                        Оберіть підходящий для вас тариф, щоб отримати доступ до більшого обсягу вакансій та інших корисних функцій.
                        """)
        elif message.text == "ℹ️ Про бот":
            self.bot.send_message(message.from_user.id, f"")
            # Показати інформацію про бота
        elif message.text == "💼 Запропонувати вакансію":
            send_job_offer_instructions(self, message.from_user.id)
            self.user_manager.set_stage(message.from_user.id, STAGE.CREATE_UNIQUE_VACANCY.value)
            self.show_create_UV_required_fields_menu(message.from_user.id)
            self.users_vacancies[message.from_user.id] = UniqueVacancy()
        elif message.text == "📞 Контакти":
          contact_info = f"""
<b>Графік роботи служби підтримки:</b>
    Пн-Пт: <b>з 10:00 до 20:00</b>
    Сб-Нд: <b>з 11:00 до 16:00</b>

<b>Контакти:</b>
  📞 <a href="tel:+380999999999">+380 (99) 999 99 99</a>
  📧 <a href="mailto:jobhunthelpersupport@gmail.com">jobhunthelpersupport@gmail.com</a>

<i>Щоб зв'язатися з менеджером, натисніть кнопку нижче:</i>
  """
                # Відправлення повідомлення з контактною інформацією
          button =  types.InlineKeyboardButton(text="📱 Зв'язатися з менеджером", url="https://t.me/anneti_net")
          # Створення клавіатури з цією кнопкою
          markup =  types.InlineKeyboardMarkup().add(button)
          self.bot.send_message(message.from_user.id, contact_info, reply_markup=markup, parse_mode="HTML")
          # # Відправлення повідомлення разом з клавіатурою
          # self.bot.send_message(chat_id, "Щоб зв'язатися з менеджером, натисніть кнопку нижче:", reply_markup=markup)
        else:
          self.show_main_menu(message.from_user.id)

    def handle_create_request(self, message):
        if message.from_user.id not in self.users_requests:
          self.users_requests[message.from_user.id] = Request()
        print(self.users_requests.get(message.from_user.id))
        if message.text == "📂 Категорія":
            self.bot.send_message(message.from_user.id, "Оберіть категорію:", reply_markup=self.generate_keyboard(categories, 3))
            self.user_manager.set_stage(message.from_user.id, STAGE.NEXT_PARAM_CATEGORY.value)
        elif message.text == "🏙 Місто":
            self.bot.send_message(message.from_user.id, "Виберіть місто для пошуку:", reply_markup=self.generate_keyboard(cities, 3))
            self.user_manager.set_stage(message.from_user.id, STAGE.NEXT_PARAM_CITY.value)
        elif message.text == "💼 Позиція":
            self.bot.send_message(message.from_user.id, "Виберіть вашу позицію:", reply_markup=self.generate_keyboard(positions, 2))
            self.user_manager.set_stage(message.from_user.id, STAGE.NEXT_PARAM_POSITION.value)
        elif message.text == "⏳ Досвід роботи":
            self.bot.send_message(message.from_user.id, "Вкажіть кількість років досвіду:")
            self.user_manager.set_stage(message.from_user.id, STAGE.NEXT_PARAM_EXPERIENCE.value)
        elif message.text == "💰 Зарплата":
            self.bot.send_message(message.from_user.id, "Вкажіть мінімальну зарплату (грн):")
            self.user_manager.set_stage(message.from_user.id, STAGE.NEXT_PARAM_MIN_SALARY.value)

    def handle_next_param_category(self, message):
        if message.text == "Розробка":
            self.bot.send_message(message.from_user.id, "Оберіть мову програмування для пошуку:", reply_markup=self.generate_keyboard(programming_languages, 3))
            self.user_manager.set_stage(message.from_user.id, STAGE.NEXT_PARAM_LANGUAGE.value)
        elif message.text == "Технічні":
            self.bot.send_message(message.from_user.id, "Оберіть технічну спеціальність для пошуку:", reply_markup=self.generate_keyboard(technical_specialties, 3))
            self.user_manager.set_stage(message.from_user.id, STAGE.NEXT_PARAM_LANGUAGE.value)
        elif message.text == "Нетехнічні":
            self.bot.send_message(message.from_user.id, "Оберіть нетехнічну спеціальність для пошуку:", reply_markup=self.generate_keyboard(nontechnical_specialties, 3))
            self.user_manager.set_stage(message.from_user.id, STAGE.NEXT_PARAM_LANGUAGE.value)

    def set_stage_create_request_and_show_menu(self, chat_id):
        self.user_manager.set_stage(chat_id, STAGE.CREATE_REQUEST.value)
        self.show_create_request_menu(chat_id)

    def handle_next_param_language(self, message):
        self.users_requests.get(message.from_user.id).set_language(message.text)
        self.set_stage_create_request_and_show_menu(message.from_user.id)

    def handle_next_param_city(self, message):
        self.users_requests.get(message.from_user.id).set_city(message.text)
        self.set_stage_create_request_and_show_menu(message.from_user.id)

    def handle_next_param_position(self, message):
        self.users_requests.get(message.from_user.id).set_position(message.text)
        self.set_stage_create_request_and_show_menu(message.from_user.id)

    def handle_next_param_experience(self, message):
        self.users_requests.get(message.from_user.id).set_experience(message.text)
        self.set_stage_create_request_and_show_menu(message.from_user.id)

    def handle_next_param_min_salary(self, message):
        self.users_requests.get(message.from_user.id).set_min_salary(message.text)
        self.set_stage_create_request_and_show_menu(message.from_user.id)

    def handle_create_unique_vacancy(self, message):
        if message.text == "⬅️":
            self.user_manager.set_stage(message.from_user.id, STAGE.START.value)
            self.show_main_menu(message.from_user.id)
        elif message.text == "Повернутись назад":
            self.user_manager.set_stage(message.from_user.id, STAGE.CREATE_UNIQUE_VACANCY.value)
            self.show_create_UV_required_fields_menu(message.from_user.id)
        elif message.text == "Додати назву вакансії":
            instructions = """
    📝 <b>Як назвати вакансію правильно?</b>

    - Використовуйте зрозумілі терміни та уникайте абревіатур, які можуть бути незрозумілі.
    - Вкажіть рівень позиції, якщо це необхідно (наприклад, Junior, Middle, Senior).

    <b>Приклад:</b>
    - Junior Python Developer
    - Senior Project Manager
    - Marketing Specialist

    <i>Напишіть назву вакансії:</i>
    """
            self.bot.send_message(message.from_user.id, instructions, parse_mode="HTML")
            self.user_manager.set_stage(message.from_user.id, STAGE.CREATE_UV_ADD_JOB_TITLE.value)
        elif message.text == "Додати категорію":
            self.bot.send_message(message.from_user.id, "Оберіть категорію з запропонованого списку", reply_markup=self.generate_keyboard(categories, 3))
            self.user_manager.set_stage(message.from_user.id, STAGE.CREATE_UV_NEXT_PARAM_CATEGORY.value)
        elif message.text == "Додати позицію":
            self.bot.send_message(message.from_user.id, "Виберіть позицію із запропонованого списку:", reply_markup=self.generate_keyboard(positions, 2))
            self.user_manager.set_stage(message.from_user.id, STAGE.CREATE_UV_ADD_POSITION.value)
        elif message.text == "Додати назву компанії":
            self.bot.send_message(message.from_user.id, "Напишіть назву компанії або ПІБ роботодавця")
            self.user_manager.set_stage(message.from_user.id, STAGE.CREATE_UV_ADD_COMPANY_NAME.value)
        elif message.text == "Додати опис вакансії":
            instructions = """
    📄 <b>Як написати опис вакансії правильно?</b>

    Опис вакансії допомагає кандидатам зрозуміти, що саме очікується від них на цій посаді, а також які навички та досвід необхідні для успішної роботи.

    <b>Основні поради:</b>
    - Вкажіть ключові обов'язки та задачі, які буде виконувати працівник.
    - Описуйте необхідні навички та кваліфікацію.
    - Зазначте умови праці, можливості для розвитку та кар'єрного росту.
    - Уникайте загальних фраз, надавайте конкретні деталі.

    <b>Приклад:</b>
    <i>
    Обов'язки:
    - Розробка та підтримка веб-додатків на Python.
    - Співпраця з командою розробників для інтеграції нових функцій.
    - Написання технічної документації.

    Вимоги:
    - Досвід роботи з Python від 2 років.
    - Знання фреймворків Django або Flask.
    - Вміння працювати з системами контролю версій (Git).

    Ми пропонуємо:
    - Конкурентну заробітну плату.
    - Гнучкий графік роботи та можливість працювати віддалено.
    - Можливості для професійного розвитку та кар'єрного росту.
    </i>

    ✏️ <i>Напишіть опис вакансії:</i>
    """
            self.bot.send_message(message.from_user.id, instructions, parse_mode="HTML")
            self.user_manager.set_stage(message.from_user.id, STAGE.CREATE_UV_ADD_DESCRIPTION.value)
        elif message.text == "Додати заробітню плату":
            instructions = """
    💵 <b>Як правильно вказати заробітну плату?</b>

    Вказування заробітної плати є важливим елементом вакансії, оскільки це може значно вплинути на кількість та якість кандидатів, які відгукнуться на вашу пропозицію.

    <b>Основні поради:</b>
    - Вказуйте заробітну плату в місячному або річному еквіваленті.
    - Зазначайте валюту (наприклад, UAH, USD, EUR).
    - Можна вказувати діапазон, якщо точна сума залежить від кваліфікації кандидата.

    <b>Приклади:</b>
    - 20,000 - 30,000 UAH
    - Від 50,000 USD на рік
    - 25,000 UAH

    📝 <i>Напишіть заробітну плату, яку ви пропонуєте:</i>
    """
            self.bot.send_message(message.from_user.id, instructions, parse_mode="HTML")
            self.user_manager.set_stage(message.from_user.id, STAGE.CREATE_UV_ADD_SALARY.value)
        elif message.text == "Додати місто роботи":
            self.bot.send_message(message.from_user.id, "Оберіть місто роботи з запропонованого списку або введіть самостійно:", reply_markup=self.generate_keyboard(cities, 3))
            self.user_manager.set_stage(message.from_user.id, STAGE.CREATE_UV_ADD_CITY.value)
        elif message.text == "Додати контакт для зв'язку":
            self.bot.send_message(message.from_user.id, " Напишіть контакт для зв'язку, який допоможе кандидатам зв'язатися з вами щодо вакансії. Ви можете вказати будь-який зручний спосіб зв'язку, такий як електронна пошта, номер телефону або логін в Telegram.")
            self.user_manager.set_stage(message.from_user.id, STAGE.CREATE_UV_ADD_CONTACT.value)
        elif message.text == "Додати досвід роботи":
            self.bot.send_message(message.from_user.id, "Напишіть необіхдну кількість років досвіду роботи")
            self.user_manager.set_stage(message.from_user.id, STAGE.CREATE_UV_ADD_EXPERIENCE.value)
        elif message.text == "Оберіть позицію із запропонованого списку":
            self.bot.send_message(message.from_user.id, "Оберіть позицію:", reply_markup=self.generate_keyboard(positions, 2))
            self.user_manager.set_stage(message.from_user.id, STAGE.CREATE_UV_ADD_POSITION.value)
        elif message.text == "➡️":
            if self.check_all_required_fields_filled(message.from_user.id):
                self.user_manager.set_stage(message.from_user.id, STAGE.CREATE_UNIQUE_VACANCY.value)
                self.show_create_UV_optional_fields_menu(message.from_user.id)
        elif message.text == "✅Готово":
            print(self.users_vacancies.get(message.from_user.id))
            self.send_new_vacancy_to_admin(message.from_user.id)
            self.bot.send_message(message.from_user.id, "Ваша вакансія відправлена на перевірку до адміністратора. Вона буде дійсна 14 днів одразу після перевірки")
            self.user_manager.set_stage(message.from_user.id, STAGE.START.value)
            self.show_main_menu(message.from_user.id)

    def check_all_required_fields_filled(self, chat_id):
        is_all_required_fields_filled = True
        str_to_user = "Ми не можемо надіслати вашу вакансію на опрацювання менеджеру, адже ви не заповнили наступні обов'язкові поля: \n"
        if self.users_vacancies.get(chat_id).title == "":
          is_all_required_fields_filled = False
          str_to_user += "- Назва\n"
        if self.users_vacancies.get(chat_id).category == "":
          is_all_required_fields_filled = False
          str_to_user += "- Категорія\n"
        if self.users_vacancies.get(chat_id).contact == "":
          str_to_user += "- Контакт\n"
          is_all_required_fields_filled = False
        if not is_all_required_fields_filled:
          self.bot.send_message(chat_id, str_to_user)
        return is_all_required_fields_filled

    def handle_create_uv_next_param_category(self, message):
        if message.text == "Розробка":
            self.bot.send_message(message.from_user.id, "Оберіть мову програмування:", reply_markup=self.generate_keyboard(programming_languages, 3))
            self.user_manager.set_stage(message.from_user.id, STAGE.CREATE_UV_ADD_CATEGORY.value)
        elif message.text == "Технічні":
            self.bot.send_message(message.from_user.id, "Оберіть технічну спеціальність:", reply_markup=self.generate_keyboard(technical_specialties, 3))
            self.user_manager.set_stage(message.from_user.id, STAGE.CREATE_UV_ADD_CATEGORY.value)
        elif message.text == "Нетехнічні":
            self.bot.send_message(message.from_user.id, "Оберіть нетехнічну спеціальність:", reply_markup=self.generate_keyboard(nontechnical_specialties, 3))
            self.user_manager.set_stage(message.from_user.id, STAGE.CREATE_UV_ADD_CATEGORY.value)

    def set_stage_create_unique_vacancy_and_show_menu(self, chat_id, is_optional):
        self.user_manager.set_stage(chat_id, STAGE.CREATE_UNIQUE_VACANCY.value)
        if not is_optional:
            self.show_create_UV_required_fields_menu(chat_id)
        else:
            self.show_create_UV_optional_fields_menu(chat_id)

    def handle_create_uv_add_job_title(self, message):
        self.users_vacancies.get(message.from_user.id).set_title(message.text)
        self.set_stage_create_unique_vacancy_and_show_menu(message.from_user.id, is_optional = False)

    def handle_create_uv_add_category(self, message):
        self.users_vacancies.get(message.from_user.id).set_category(message.text)
        self.set_stage_create_unique_vacancy_and_show_menu(message.from_user.id, is_optional = False)

    def handle_create_uv_add_company_name(self, message):
        self.users_vacancies.get(message.from_user.id).set_company(message.text)
        self.set_stage_create_unique_vacancy_and_show_menu(message.from_user.id, is_optional = True)

    def handle_create_uv_add_description(self, message):
        self.users_vacancies.get(message.from_user.id).set_description(message.text)
        self.set_stage_create_unique_vacancy_and_show_menu(message.from_user.id, is_optional = True)

    def handle_create_uv_add_salary(self, message):
        self.users_vacancies.get(message.from_user.id).set_salary(message.text)
        self.set_stage_create_unique_vacancy_and_show_menu(message.from_user.id, is_optional = True)

    def handle_create_uv_add_experience(self, message):
        self.users_vacancies.get(message.from_user.id).set_experience(message.text)
        self.set_stage_create_unique_vacancy_and_show_menu(message.from_user.id, is_optional = True)

    def handle_create_uv_add_city(self, message):
        self.users_vacancies.get(message.from_user.id).set_city(message.text)
        self.set_stage_create_unique_vacancy_and_show_menu(message.from_user.id, is_optional = True)

    def handle_create_uv_add_contact(self, message):
        self.users_vacancies.get(message.from_user.id).set_contact(message.text)
        self.set_stage_create_unique_vacancy_and_show_menu(message.from_user.id, is_optional = False)

    def handle_create_uv_add_position(self, message):
        self.users_vacancies.get(message.from_user.id).set_position(message.text)
        self.set_stage_create_unique_vacancy_and_show_menu(message.from_user.id, is_optional = True)

    def start_search(self, message):
        self.show_main_menu(message.from_user.id)
        print("start_seach_and_send_unique_vacancy")
        if self.users_requests.get(message.from_user.id).add_request_to_db(message.from_user.id, self.db_manager):
          #stop_scheduler()
          start_seach_and_send_unique_vacancy(self.users_requests.get(message.from_user.id), message.from_user.id)
          threads = []
          threads.append(threading.Thread(target=start_seach_and_send_workua_vacancy, args=(self.users_requests.get(message.from_user.id), message.from_user.id)))
          threads.append(threading.Thread(target=start_seach_and_send_dou_vacancy, args=(self.users_requests.get(message.from_user.id), message.from_user.id)))
          threads.append(threading.Thread(target=start_seach_and_send_djinni_vacancy, args=(self.users_requests.get(message.from_user.id), message.from_user.id)))
          threads.append(threading.Thread(target=start_seach_and_send_robota_vacancy, args=(self.users_requests.get(message.from_user.id), message.from_user.id)))
          threads.append(threading.Thread(target=start_seach_and_send_jooble_vacancy, args=(self.users_requests.get(message.from_user.id), message.from_user.id)))

          for thread in threads:
              thread.start()

          for thread in threads:
              thread.join()
           #start_scheduler()
          self.user_manager.set_stage(message.from_user.id, STAGE.START.value)
          del self.users_requests[message.from_user.id]
        else:
          self.bot.send_message(message.from_user.id, "Такий запит вже існує.")
          self.user_manager.set_stage(message.from_user.id, STAGE.START.value)
          del self.users_requests[message.from_user.id]

TOKEN = '7161535193:AAG2EDGz-thMU4zFHRS0ZC3OoqnmGr9L79E'
PAYMENTS_PROVIDER_TOKEN = '1661751239:TEST:mU24-EUf1-h8WQ-vwr0'

bot = telebot.TeleBot(TOKEN)
request = Request()

def get_end_subscription_date():
    current_date = datetime.now().date()
    return current_date + relativedelta(months=1)

cities = ["Повернутися в головне меню", "remote", "Kyiv", "Vinnytsia", "Dnipro", "Ivano-Frankivsk", "Zhytomyr", "Zaporizhzhia", "Lviv", "Mykolaiv", "Odesa", "Ternopil", "Kharkiv", "Khmelnytskyi", "Cherkasy", "Chernihiv", "Chernivtsi", "Uzhhorod"]
positions = ["Повернутися в головне меню", "Trainee","Intern" , "Junior", "Middle", "Senior", "Team Lead", "Chief of", "Head of"]

categories = ["Розробка", "Технічні", "Нетехнічні"]

programming_languages = ["Повернутися в головне меню", "JavaScript", "Front-End", "Fullstack", "Java", "C#", ".NET", "Python", "PHP", "Node.js", "iOS", "Android", "React Native", "C", "C++", "Embedded", "Flutter", "Golang", "Ruby", "Scala", "Salesforce", "Rust", "Elixir", "Kotlin", "ERP Systems"]
technical_specialties = ["Повернутися в головне меню", "QA Manual", "QA Automation", "Design", "2D/3D Artist", "Illustrator", "Gamedev", "Project Manager", "Product Manager", "Product Owner", "Delivery Manager", "Scrum Master", "Agile Coach", "Architect", "CTO", "DevOps", "Security", "Sysadmin", "Business Analyst", "Data Science", "Data Analyst", "Data Engineer", "SQL", "DBA", "Technical Writing"]
nontechnical_specialties = ["Повернутися в головне меню", "Marketing", "Sales", "Lead Generation", "SEO", "HR Recruiter", "Customer Support", "Technical Support", "Head", "Chief", "Finances"]

db_config = {
    "host": "0.tcp.eu.ngrok.io",
    "port": 13051,
    "user": "root",
    "password": "root",
    "database": "scraping_service"
}

db_manager = DatabaseManager(db_config)
user_manager = UserManager(db_manager)
admin_manager = AdminManager(db_manager)

# scheduler = JobScheduler(db_manager)
# scheduler.start_scheduler()
# threading.Thread(target=scheduler.run_scheduler).start()

bot_manager = BotManager(TOKEN, PAYMENTS_PROVIDER_TOKEN, db_manager, user_manager, admin_manager)
bot_manager.run()

scheduler.stop_scheduler()

# ЗАДАЧІ:
# DONE 2. Зробити видалення своїх вакансій за допомогою кнопки під вакансією #done
# DONE 3. Перевірка на кількість реквестів, щоб більше ніж доступно не можна було зробити
# 4. В цілому зробити більш гарний інтерфейс
# DONE 5. Зробити шоб після перезапуска фоновий пошук вакансій запускався автоматично, а не після того, як ми вручну додали новий запит
# DONE 6. Перевірити як інші сайти працюють з "С++", "С#", якщо є проблеми - швидко виправити аналогічно до workua
# DONE 7. Спробувати запустити бот локально в PyCharm і перевірити як швидко буде працювати з запитами до БД
# DONE 8. Реалізувати допоміжні функції для robota
# Для djini какая-то защита стоит, не понятно, походу нельзя скрапить полную информацию о вакансии
# 9. Зробити, щоб виводилось по 10 запитів, а інші щоб після натискання кнопки ЩЕ
# DONE 10. Зробити функцінал для додавання унікальних вакансій, які є лише в боті
# DONE 10. Функціонал щоб не тільки скрапити, а й перевіряти унікальні вакансії
# 11. Поправить форматирование уникальных вакансий
# REJECTED 11. Додати адміна, мабуть зробити для нього трохи інший інтерфейс
# 12. Перевірити, чи всі кнопки працюють і різних комбінаціях, бо здається що ні, рішення пов'язане з ставновленням stage - можливо вирішено?
# Посмотреть что нет так с запросом C#, скрин есть ?
# DONE 13. Сделать правильный stage, хранить его в базе данных! АЛЕ довго працює в colab
# DONE 14. В базе данних сделать дефолтное значение img_src
# DONE 15. Пофиксить ненужное моргание кнопок
# 16. Сделать чтобы юзер мог сразу несколько вакансий добавлять, и сделать чтобы это было по подписке
# 17. Если сможем чтобы админ мог оставлять коментарий удалению вакансии и редактировать мог
# DONE 18. Не уверен, возможно какой-то баг в скрапинге вакансий на фоне, почему-то по несколько раз одинаковые присылаются. Можно глянуть детальнее - ПОЧТИ на 100% уверен что связано с длинной то-ли заголовка, то-ли чего-то такого
# DONE 19. Добавить уникальные вакансии в поиске на фоне тоже
# 20. Подумать, может сделать чтобы по одной вакансии в бд добавлялось и сразу отправлялось?
# 21. Сделать чтобы логи выводились

# IN PROGRESS. Рефакторинг коду, створити класи, щоб все гарно виглядало - можна зробити на будь якому етапі, бажано якомога раніше
# DONE!. Можливо ще подумати з приводу оплати тарифів грошима
# . Задеплоїти систему (optional), але бажано